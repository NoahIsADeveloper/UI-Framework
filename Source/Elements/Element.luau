--!optimize 2
--!strict

local Signal = require("../Utils/Signal")

local VectorXY = require("../Utils/VectorXY")
local FlexXY = require("../Utils/FlexXY")

local Element = {} :: Element
Element.__index = Element
export type Element = typeof(setmetatable({} :: {
	__index: Element,

	-- // Properties
	anchorPoint: VectorXY.VectorXY,

	actualSize: VectorXY.VectorXY,
	size: FlexXY.FlexXY,

	actualPosition: VectorXY.VectorXY,
	position: FlexXY.FlexXY,

	parent: Element?,
	children: {Element},

	-- // Signals
	PositionChanged: Signal.Signal,
	SizeChanged: Signal.Signal,
	ParentChanged: Signal.Signal,

	ChildAdded: Signal.Signal,

	-- // Methods
	DefineProperties: (self: Element) -> (),
	DefineSignals: (self: Element) -> (),

	CalculateLayout: (self: Element) -> (),
	Reparent: (self: Element, parent: Element?) -> (boolean),
	Resize: (self: Element, size: FlexXY.FlexXY) -> (boolean),
	Render: (self: Element) -> (Instance),

	new: (self: Element, parent: Element?) -> (Element),
}, Element))

local function isElement(value: any): (boolean)
	return type(value) == "table" and getmetatable(value) == Element
end

function Element:DefineSignals(): ()
	self.ParentChanged = Signal.new()
	self.SizeChanged = Signal.new()
	self.PositionChanged = Signal.new()
	self.ChildAdded = Signal.new()
end

function Element:DefineProperties(): ()
	self.size = FlexXY.new(0, 100, 0, 100)
	self.position = FlexXY.new(0, 0, 0, 0)
	self.anchorPoint = VectorXY.new(0.5, 0.5)

	self:CalculateLayout()
end

function Element:CalculateLayout(): ()
	if self.parent then
		self.actualSize = self.size:ToOffset(self.parent.actualSize)
		self.actualPosition = self.parent.actualPosition + self.position:ToOffset(self.parent.actualSize)
	else
		self.actualSize = self.size:ToOffset()
		self.actualPosition = self.position:ToOffset()
	end

	self.actualPosition -= self.anchorPoint * self.actualSize

	for _, child in self.children do
		child:CalculateLayout()
	end
end

function Element:Resize(size: FlexXY.FlexXY): (boolean)
	local oldSize = self.size

	self.size = size
	self:CalculateLayout()
	self.SizeChanged:Fire(size, oldSize)

	return true
end

function Element:Reparent(parent: Element?): (boolean)
	local oldParent = self.parent
	if oldParent == parent then return false end
	if parent ~= nil and not isElement(parent) then return false end

	if oldParent then
		local index = table.find(oldParent.children, self)
		if index then
			table.remove(oldParent.children, index)
		end
	end

	if parent then
		table.insert(parent.children, self)
		parent.ChildAdded:Fire(self)
	end

	self.parent = parent
	self:CalculateLayout()
	self.ParentChanged:Fire(parent, oldParent)

	return true
end

function Element:Render(): (Instance)
	local frame = Instance.new("Frame")
	frame.Size = self.actualSize:ToUDim2()
	frame.Position = self.actualPosition:ToUDim2()

	frame.Parent = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	return frame
end

function Element:new(parent: Element?): (Element)
	local object = setmetatable({
		parent = nil,
		children = {},
	}, self) :: any

	object:DefineSignals()
	object:DefineProperties()
	object:Reparent(parent)

	return object
end

return Element
